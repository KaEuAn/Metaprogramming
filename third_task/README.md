## Структура "Посетитель", функтор

В файле *Functor.h* определён класс `Functor`, который в конструкторе принимает вызываемую функцию, а затем вызов функтора будет тождественен вызову функции, которую мы ему передали. Шаблонный параметр - тип фукнции (как в *std::function*)

В качестве паттерна "Посетителя" рассмотрим ситуацию, когда есть написанный класс персонажей компьютерной игры. Компания "Метелица", разрабатывающая компьютерную игру, знаменита большим количеством багов при апдейтах и патчах, поэтому балансные правки персонажей решено было вынести наружу из класса, чтобы изменять работающий код по минимуму, для чего и подходит наш паттерн.

Итого, как пример, у нас есть классы `Brigitte` и `Genji` - персонажи игры, у каждого есть свои свойства, наследуются от класса `Hero`. Есть классы `Buff` и `Nerf` -- классы Посетители, которые изменяют наших персонажей с помощью метода `Visit`, классы унаследованы от `Visitor`. Чтобы применить нерф или бафф к персонажу, нужно завести шаблонный класс `VisitFactory`, шаблонными аргументами которого являются базовые классы и тайплисты вариантов, а затем для этой фабрики вызвать метод `make`, в который передаётся `Visitor`, `Acceptor` и аргументы внешней обработки.

`VisitFactory` с помощью спецификаций проходит по тайплистам и находит нужное соответствие `Visitor` и `Acceptor` с помощью `dynamic_cast`, чтобы можно было принимать общие классы (если, например, есть *vector* всех персонажей в виде `Hero`). 

Затем вызывается конкретная реализация функтора под этих `Visitor` и `Acceptor`. Как пример добавлена опция `print`, отвечающая за то, надо ли выводить на экран информацию о конкретных нерфах и баффах. Опции же нерфов и баффов задаются в самих классах `Buff` и `Nerf`, и их можно менять, это кажется логичным и удобным. Как параметры доп.обработки в реальности могут быть параметры тестового запуска интерфейса после изменения конкретного класса, а запуск будет происходить в самом функторе.